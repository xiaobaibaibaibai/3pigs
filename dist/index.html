<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <style>
        .section {
            padding-left: 2%;
            padding-right: 5%;
            margin-bottom: 20px;
        }

        #sign {
            height: 15px;
            width: 15px;
        }
        
        .detail {
            display: none;
        }

        ul {
            margin: 0%;
        }

        ol {
            margin: 0%;
        }

    </style>
</head>

<body>
    <div class="section">
        <span>JavaScript类型</span>
        <button class="displayBn" onclick="hiddenOrShow(0)">show</button>
        <div class="detail">
            <span>七种基本数据类型 (存放在栈(stack)内存)</span> 
            <ul>
                <li>Boolean: 有2个值分别是：true 和 false.</li>
                <li>null : 一个表明 null 值的特殊关键字。</li>
                <li>undefined: 和null一样是一个特殊的关键字, undefined表示变量未定义时的属性。</li>
                <li>Number: 整数或浮点数，例如： 42 或者 3.14159。</li>
                <li>String: 字符串是一串表示文本值的字符序列，例如："Howdy" 。</li>
                <li>BigInt:可以安全地存储和操作大整数，甚至可以超过数字的安全整数限制。</li>
                <li>Symbol: ( 在ES6新加).。一种实例是唯一且不可改变的数据类型。</li>
            </ul>
            <span>一种Object(对象)引用类型，指针放在栈(stack)里，对象放在堆(heap)内存中. Object又可以分为function和object两种
                ，再往下细分又可以分成 array，function，regex，date，object这几常见的种类型</span>
        </div>
    </div>

    <div class="section">
        <span><a href="https://segmentfault.com/a/1190000014456603" target="_blank">类型判断</a></span>
        <button class="displayBn" onclick="hiddenOrShow(1)">show</button>
        <div class="detail">
            <ul>
                <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof"  target="_blank">typeof</a> 返回全小写字符串: number, string, boolean, object, undefined, function. 适合判断出基本类型. 
                    缺点: 判断Object的具体类型时不好用, typeof [ ], typeof null, typeof new Date()都返回object</li>
                <li>instanceof 返回true/false. 用 A instanceof B 判断A的原型链上是否有B的prototype属性. 缺点: 无法判断基本类型, 基本类型都返回false.
                     只要能在原型链上找到的, 都返回true, 所以数组instanceof Array和Object都返回true. 不可以用于undefined和null，因为他们都不是object，会直接报错</li>
                <li>constructor 和instanceof差不多, 但是  [ ].constructor === Object 返回false. [].constructor === Array返回true. 缺点: 继承的对象判断时，不准确</li>
                <li>Object.prototype.toString.call(obj) 最靠谱, 返回字符串 [object String], [object Boolean], [object Undefined], [object Null], 
                    [object Function], [object Array], [object RegExp], [object Date], [object Error], [object HTMLDocument], [object Window]</li>
            </ul>
        </div>
    </div>

    <div class="section">
        <span><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call" target="_blank">call()</a>
             和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" target="_blank">apply()</a></span>
        <button class="displayBn" onclick="hiddenOrShow(2)">show</button>
        <div class="detail">
            <span>两者都是使用一个指定的 this 值，然后 call() 方法接受的是一个参数列表，而 apply() 方法接受的是一个包含多个参数的数组</span><br>
            <span>somefuntion.call(this, arg1,arg2, ….)</span><br>
            <span>somefuntion.apply(this, [arg1, arg2,...])</span><br>
        </div>
    </div>

    <div class="section">
        <span><a href="https://juejin.im/post/5b1d1fd6f265da6e410e137c" target="_blank">ES6新功能</a></span>
        <button class="displayBn" onclick="hiddenOrShow(3)">show</button>
        <div class="detail">
            <ul>
                <li>const和let</li>
                <li>箭头函数</li>
                <li>函数的参数默认值 function fn(a = 1){}</li>
                <li>for...of 遍历一个集合里面所有的元素， for...in 便利一个对象里面所有的属性</li>
                <li>支持 class 语法，又class, extend, super,constructor这些关键字和元素了</li>
            </ul>
        </div>
    </div>

    <div class="section">
        <span><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank">箭头函数（ES6）</a></span>
        <button class="displayBn" onclick="hiddenOrShow(4)">show</button>
        <div class="detail">
            <span>语法比函数表达式更简洁，并且没有自己的this，arguments，super或new.target。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。</span><br>
            <span>this: 箭头函数不会创建自己的this,它只会从自己的作用域链的上一层继承this</span><br>
            <span>Arguments: 箭头函数不绑定Arguments 对象, 其中 arguments[i] 的值是undefined</span><br>
        </div>
    </div>

    <div class="section">
        <span>var, let, const</span>
        <button class="displayBn" onclick="hiddenOrShow(5)">show</button>
        <div class="detail">
            <span>作用域</span>
            <ul>
                <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/var" target="_blank">var</a>作用域限制在其声明位置的上下文中，可以是全局或本地声明的块</li>
                <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let" target="_blank">let</a>的作用域只在其声明的块或子块中可用，块就是{}</li>
                <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/const" target="_blank">const</a>的作用域可以是全局或本地声明的块</li>
            </ul>
            <span>重复声明：var可以，let和const不可以</span><br>
            <span>暂存死区：let和const都是声明的变量直到它们的定义被执行时才初始化，而var是声明变量在任何代码执行前创建。</span>
        </div>
    </div>

    <div class="section">
        <span>Array</span>
        <button class="displayBn" onclick="hiddenOrShow(6)">show</button>
        <div class="detail">
            <span>创建一个数组用[ ], 或者 Array.from(另一个array,set, map, arguments都可以) // 浅拷贝
                数组去重就用set
                </span><br>
            <span><a href="https://www.jianshu.com/p/4a3844d3c8b9" target="_blank">常用方法</a></span>
            <ul>
                <li>遍历整个数组：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" target="_blank">forEach</a>, 
                    <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank">map</a>, 
                    <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" target="_blank">filter</a>, 
                    <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce" target="_blank">reduce</a></li>
                <li>单个元素：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/push" target="_blank">push</a>, 
                    <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/pop" target="_blank">pop</a>, 
                    <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf" target="_blank">indexof</a>, 
                    <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/shift" target="_blank">shift</a>, 
                    <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift" target="_blank">unshift</a></li>
                <li>对整个数组操作：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/splice" target="_blank">splice</a>, 
                    <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" target="_blank">slice</a>, 
                    <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/concat" target="_blank">concate</a></li>
            </ul>
        </div>
    </div>

    <div class="section">
        <span>Object常用方法</span>
        <button class="displayBn" onclick="hiddenOrShow(7)">show</button>
        <div class="detail">
            <ul>
                <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys" target="_blank">keys()</a> 和 
                    <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/values" target="_blank">values()</a> 都是返回一个数组</li>
                <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank">create()</a>创建一个新对象，使用现有的对象obj来提供新创建的对象的__proto__</li>
                <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty" target="_blank">hasOwnProperty</a>() 判断对象自身属性中是否具有指定的属性</li>
                <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank">defineProperty</a>() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性。</li>
                <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze" target="_blank">freeze</a>()方法可以冻结一个对象。一个被冻结的对象再也不能被修改。冻结一个对象后该对象的原型也不能被修改</li>
                <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank">其他方法</a></li>
            </ul>
        </div>
    </div>

    <div class="section">
        <span>创建对象</span>
        <button class="displayBn" onclick="hiddenOrShow(8)">show</button>
        <div class="detail">
            <ol>
                <li>构造函数法：写一个function在其内部用this关键字指代实例对象。生成实例的时候，使用new关键字。还可以用function.prototype往上面添加新的属性</li>
                <li>
                    <span>Object的方法</span>
                    <ul>
                        <li>Object.create(obj)创建一个新对象，使用现有的对象obj来提供新创建的对象的__proto__(单继承关系)</li>
                        <li>Object.assign({}, obj)创建一个新对象，浅拷贝，非继承关系</li>
                    </ul>
                </li>
                <li>还可以用工厂模式，这个就是在一个对象里面专门写一个生成新对象的方法，可以用来继承各种属性和函数</li>
            </ol>
        </div>
    </div>

    <div class="section">
        <span>new的原理过程</span>
        <button class="displayBn" onclick="hiddenOrShow(9)">show</button>
        <div class="detail">
            <span>var obj = new fn() 底层原理过程是</span>
            <ol>
                <li>创建一个ECMAScript原生对象obj</li>
                <li>把新对象obj的内部属性[[class]]设置为Object</li>
                <li>把新对象obj的__proto__设为创建它的构造函数fn的protoptype</li>
                <li>然后执行创建obj的构造函数fn()，把函数里面的this都指向这个新对象obj，把fn里面的内容都执行了</li>
                <li>最后返回这个对象obj</li>
            </ol>
            <span></span>
            <a href="" target="_blank"></a>
        </div>
    </div>

    <div class="section">
        <span>_proto_和prototype</span>
        <button class="displayBn" onclick="hiddenOrShow(10)">show</button>
        <div class="detail">
            <span>最直觀的差別是</span>
            <ul>
                <li>__proto__是每个对象都有的一个属性，而prototype是函数才会有的属性。</li>
                <li>__proto__指向的是当前对象的原型对象，而prototype指向的，是以当前函数作为构造函数构造出来的对象的原型对象。</li>
            </ul>
            <span>
                如果 var obj = new fn() 那么：<br>
                obj.__proto__ == fn.prototype<br>
                fn.prototype == Object<br>
                fn.prototype.__proto__ == Object.prototype<br>
                Object.prototype.__proto__ == null
            </span>
        </div>
    </div>

    <div class="section">
        <span>闭包 Closure</span>
        <button class="displayBn" onclick="hiddenOrShow(11)">show</button>
        <div class="detail">
            <span>
                闭包比较口头的定义：就是构建了一个函数，这个函数能够得到其他函数内部的变量<br>
                主要是用于解决作用域的问题，主要用途有两个：
            </span>
            <ul>
                <li>封装(保护函数内的变量安全, 模拟私有方法)</li>
                <li>让函数内部的变量的值始终保持在内存中</li>
            </ul>
            <span>
                <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures" target="_blank">MDN</a><br>
                <a href="https://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" target="_blank">阮一峰</a>
            </span>
        </div>
    </div>

    <div class="section">
        <span>事件循环 Event-Loop</span>
        <button class="displayBn" onclick="hiddenOrShow(12)">show</button>
        <div class="detail">
            <ol>
                <li>所有同步任务都在主线程上执行，形成一个执行栈</li>
                <li>主线程之外，维护一个宏任务队列(tasklist)。每一个宏任务又维护自己的微任务队列(microtasklist)</li>
                <li>一旦执行栈中的所有同步任务执行完毕，检查还有没有微任务需要处理。</li>
                <li>结束本次宏任务、检查还有没有宏任务需要处理。如果有，系统就会读取宏任务队列,将队列中的事件放到执行栈中依次执行</li>
                <li>主线程从宏任务队列中读取事件，这个过程是循环不断的</li>
            </ol><br>
            <span>同步任务</span>
            <ul>
                <li>没有同步异步的代码</li>
                <li>Promise(function())中的 function 部分</li>
                <li>asyn function 中用 await 调用一个函数 fn()，按顺序执行 await 之前的内容和 fn() 里面的内容</li>
            </ul><br>
            <span>微任务(micro tasks)</span>
            <ul>
                <li>Promise.then()部分</li>
                <li>await fn() 后面的内容</li>
            </ul><br>
            <span>宏任务(macro tasks)</span>
            <ul>
                <li>setTimeout</li>
                <li>setIntervel</li>
            </ul><br>
            <span>同步任务 > 微任务 > 宏任务, 同等级的任务是按照代码顺序来执行</span>
        </div>
    </div>

    <div class="section">
        <span><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank">Promise</a></span>
        <button class="displayBn" onclick="hiddenOrShow(13)">show</button>
        <div class="detail">
            <span>
                对象用于表示一个异步操作的最终完成 (或失败), 及其结果值<br>
                有以下几种状态:
            </span>
            <ul>
                <li>pending: 初始状态，既不是成功，也不是失败状态。</li>
                <li>fulfilled: 意味着操作成功完成。调用resolve()函数时把状态转换为fulfill</li>
                <li>rejected: 意味着操作失败。调用reject()转换为rejected</li>
            </ul>
            <span>
                这三个状态影响了调用then()函数。<br><br>
                then() 方法最后会返回一个新的 Promise对象，可以赋两个参数<br>
                如果当前Promise对象是
            </span>
            <ul>
                <li>fulfilled: 调用fulfilled状态下的函数，也是就是第一个参数</li>
                <li>rejected: 调rejected状态下的函数，也是就是第二个参数</li>
                <li>pending: 两个参数都不调用</li>
            </ul><br>
            <span>
                Promise 和 then 的原理大概是 Promise 内部有一个变量data，调用resolve()或reject()的时候就把他们的参数赋值给data，然后再then()里面就可以用这个data。<br>
                在调用then()的时候当会创建一个新的promise对象，如果当前状态是fulfilled或者rejected状态，调用对应的函数，然后将结果付给新建的promise，返回这个promise；如果当前是pending状态，当前promise就一定要等待直到状态不是pending<br>
                之所以then部分是微任务是因为用了process.nextTick(function)这个方法，这个就是把任务插到任务队列的最后面了<br>
            </span><br>
            <span>
                async function和 await<br>
                只有在async function 中才可以用 await 表达式<br>
                await 表达式会暂停当前 async function 的执行，等待 Promise 处理完成。
            </span>
            <ul>
                <li>若 Promise 正常处理，其回调的resolve函数参数作为 await 表达式的值，继续执行 async function</li>
                <li>若 Promise 处理异常，await 表达式会把 Promise 的异常原因抛出</li>
            </ul>
            <span>另外，如果 await 操作符后的表达式的值不是一个 Promise，则返回该值本身。</span><br>
            <pre>
            new Promise(function(resolve, reject) {
                console.log("resolve1");
                resolve("111");
            }).then(function(data) {
                // resolve run
                console.log("Promise1 : " + data);
                return "222";
            }, function(error) {
                // reject run
                console.log("fail : " + error);
                return "404";
            }).then(function(data) {
                console.log("Promise2 : " + data);
            });
            </pre>
        </div>
    </div>


    <div class="section">
        <span>NodeJS文件读取</span>
        <button class="displayBn" onclick="hiddenOrShow(14)">show</button>
        <div class="detail">
            <pre>
            单线程 但是 异步式 I/O (或者非阻塞 I/O)
            var fs = require('fs');
            fs.readFile('file.txt', 'utf8', function(err, data){
                if(err) {
                    console.log(err);
                }
                else {
                    console.log(data);
                }
            });
            console.log('end')                
            </pre>
        </div>
    </div>

    <div class="section">
        <span>遍历Object</span>
        <button class="displayBn" onclick="hiddenOrShow(15)">show</button>
        <div class="detail">
            <pre>
            let keys = Object.keys(obj);
            keys.forEach(function(key) {
                console.log(key + ": " + obj[key]);
            });
            
            for (let key in obj) {
                if (obj.hasOwnProperty(key)) {
                    console.log(key + ": " + obj[key]);
                }
            }                
            </pre>
        </div>
    </div>

    <div class="section">
        <span>转换</span>
        <button class="displayBn" onclick="hiddenOrShow(16)">show</button>
        <div class="detail">
            <pre>
            //字符串转对象
            let obj = JSON.parse(jsonStr)
                
            // 对象转字符串
            let str = JSON.stringify(obj)                
            </pre>
        </div>
    </div>

    <div class="section">
        <span><a href="https://segmentfault.com/a/1190000016418021#item-11" target="_blank">数组去重</a></span>
        <button class="displayBn" onclick="hiddenOrShow(17)">show</button>
        <div class="detail">
            <pre>
            // new set, ES6
            function unique (arr) {
                return Array.from(new Set(arr))
            }
                
            // indexOf
            function indexOfWay (arr) {
                var array = [];
                for (var i = 0; i < arr.length; i++) {
                    if (array .indexOf(arr[i]) === -1) {
                        array.push(arr[i])
                    }
                }
                return array;
            }
                
            function sortWay (arr) {
                arr = arr.sort();
                // 去重
            }
                
            function mapWay(arr) {
                let map = new Map();
                let array = new Array();
                for (let i = 0; i < arr.length; i++) {
                    if(map.has(arr[i])) {
                        map.set(arr[i], true); 
                    } else { 
                        map.set(arr[i], false);
                        array.push(arr[i]);
                    }
                }
                return array;
            }
            
            Array.prototype.deduplicate = function() {
                let res = [];
                for (let i = 0; i < this.length; i++) {
                    if (this.indexOf(this[i], i+1) > 0) {
                        res.push(this.shift());
                        i--;
                    }
                }
                return res;
            }
            let input = ['1', '2', '3', '1', '2']
            console.log(input.deduplicate());
            </pre>
        </div>
    </div>

    <div class="section">
        <span>curry的实现</span>
        <button class="displayBn" onclick="hiddenOrShow(18)">show</button>
        <div class="detail">
            <pre>
            function curry (fn, arr = []) {
                if (fn.length === arr.length) {
                    return fn.apply(null, arr);
                } else {
                    return function (...args) {
                        return curry (fn, arr.concat(args));
                    } 
                }
            }                
            </pre>
        </div>
    </div>

    <div class="section">
        <span>数组合并</span>
        <button class="displayBn" onclick="hiddenOrShow(19)">show</button>
        <div class="detail">
            <pre>
            let a = [1, 2, 3]
            let b = ['a', 'b', 'c']
            let c = [...a, ...b]
            </pre>
        </div>
    </div>



    <div class="section" style="display: none;">
        <span></span>
        <button class="displayBn" onclick="hiddenOrShow(-1)">show</button>
        <div class="detail">
            <ul>
                <li></li>
                <li></li>
                <li></li>
            </ul>
            <span></span>
            <a href="" target="_blank"></a>
        </div>
    </div>

    <div class="section" style="display: none;">
        <span></span>
        <button class="displayBn" onclick="hiddenOrShow(-2)">show</button>
        <div class="detail">
            <pre>

            </pre>
        </div>
    </div>

    <script>
        function hiddenOrShow(id) {
            let detail = document.getElementsByClassName('detail')[id];
            let button = document.getElementsByClassName('displayBn')[id];
            let display = detail.style.display;
            if (display === 'block') {
                detail.style.display = 'none';
                button.innerHTML = 'show';
            } else {
                detail.style.display = 'block';
                button.innerHTML = 'hide';
            }
        }
    </script>
</body>
</html>